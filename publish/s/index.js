const u=[];let s,d;function v(n){const e=(...t)=>{if(!t.length)return s&&!e.observers.has(s)&&(e.observers.add(s),s.signals.push(e)),n;const[a]=t;if(d)return e.pending===u&&d.push(e),e.pending=a,a;n=a;const r=s;return s=void 0,e.observersRan=new Set(e.observers),e.observersRan.forEach(i=>{i.stale=!0}),e.observersRan.forEach(i=>{i.stale&&i()}),s=r,n};return e.$o=1,e.observers=new Set,e.observersRan=void 0,e.pending=u,e}function c(n){let e;const t=()=>{const r=s;s&&s.children.push(t);const i=t.children;p(t),t.stale=!1,s=t,e=n(),i.forEach(o=>{t.children.indexOf(o)===-1&&(o.stale=!1)});const h=o=>o.reduce((l,f)=>l.concat(f,h(f.children)),[]),m=h(t.children);return m.forEach(o=>{o.stale||o.signals.forEach(l=>{l.observersRan&&l.observersRan.delete(o)})}),s=r,e};t.stale=!0,t.signals=[],t.children=[];const a=()=>(t.stale?e=t():t.signals.forEach(r=>{r()}),e);return a.$o=1,a.update=t,n.update=t,g(t),t(),a}function y(n){return c(n),()=>T(n)}function T(n){return p(n.update)}function p(n){n.children.forEach(p),n.signals.forEach(e=>{e.observers.delete(n),e.observersRan&&e.observersRan.delete(n)}),g(n)}function g(n){n.signals=[],n.children=[]}function S(n){const e=d;d=[];const t=n(),a=d;return d=e,a.forEach(r=>{if(r.pending!==u){const{pending:i}=r;r.pending=u,r(i)}}),t}function b(n){const e=s;s=void 0;const t=n();return s=e,t}function U(n,e,t={onlyChanges:!0}){return n=[].concat(n),c(()=>{n.forEach(r=>{r()});let a;return t.onlyChanges||(a=b(e)),t.onlyChanges=!1,a})}export{c as computed,U as on,v as s,b as sample,v as signal,y as subscribe,S as transaction,T as unsubscribe};
//# sourceMappingURL=index.js.map
