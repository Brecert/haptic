const p=[];let a,d;function y(n){const e=(...t)=>{if(!t.length)return a&&!e.obs.has(a)&&(e.obs.add(a),a.signals.push(e)),n;const[s]=t;if(d)return e.pending===p&&d.push(e),e.pending=s,s;n=s;const i=a;return a=void 0,e.obsLive=new Set(e.obs),e.obsLive.forEach(r=>{r.stale=!0}),e.obsLive.forEach(r=>{r.stale&&r()}),a=i,n};return e.$o=1,e.obs=new Set,e.obsLive=void 0,e.pending=p,e}function c(n){let e;const t=()=>{const i=a;a&&a.children.push(t);const r=t.children;u(t),t.stale=!1,a=t,e=n(),r.forEach(o=>{t.children.indexOf(o)===-1&&(o.stale=!1)});const h=o=>o.reduce((l,f)=>l.concat(f,h(f.children)),[]),m=h(t.children);return m.forEach(o=>{o.stale||o.signals.forEach(l=>{l.obsLive&&l.obsLive.delete(o)})}),a=i,e};t.stale=!0,t.signals=[],t.children=[];const s=()=>(t.stale?e=t():t.signals.forEach(i=>{i()}),e);return s.$o=1,s.update=t,n.update=t,g(t),t(),s}function S(n){return c(n),()=>b(n)}function b(n){return u(n.update)}function u(n){n.children.forEach(u),n.signals.forEach(e=>{e.obs.delete(n),e.obsLive&&e.obsLive.delete(n)}),g(n)}function g(n){n.signals=[],n.children=[]}function U(n){const e=d;d=[];const t=n(),s=d;return d=e,s.forEach(i=>{if(i.pending!==p){const{pending:r}=i;i.pending=p,i(r)}}),t}function T(n){const e=a;a=void 0;const t=n();return a=e,t}function v(n,e,t={onlyChanges:!0}){return n=[].concat(n),c(()=>{n.forEach(i=>{i()});let s;return t.onlyChanges||(s=T(e)),t.onlyChanges=!1,s})}export{c as computed,v as on,y as s,T as sample,y as signal,S as subscribe,U as transaction,b as unsubscribe};
//# sourceMappingURL=index.js.map
