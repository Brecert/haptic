var R=0,w=0,a,T,S=new Set,l=new WeakMap,f=0,y=1,E=2,u=3,b=4,A=e=>{let o=`rx#${w++}(${e.name})`,t={[o](){p(t)}}[o];return t.fn=e,t.runs=0,t.depth=a?a.depth+1:0,S.add(t),a&&a.inner.add(t),i(t),t},p=e=>{if(e.state===E)throw new Error(`Loop ${e.name}`);if(e.state===u)e.inner.forEach(p);else{i(e),e.state=E;let o=(...t)=>t.map(r=>r(o));l.set(o,e),h(e,()=>e.fn(o)),e.runs++}e.state=e.sr.size?y:f},i=e=>{e.state=f,e.runs&&(e.inner.forEach(i),e.sr.forEach(o=>o.rx.delete(e))),e.sr=new Set,e.pr=new Set,e.inner=new Set},k=e=>{e.state=u,e.inner.forEach(k)},V=e=>(Object.keys(e).forEach(o=>{let t=e[o],r,s=`vocal#${R++}(${o})`,n={[s](...d){if(!d.length){if(a){if(a.sr.has(n))throw new Error(`Mixed sr/pr ${n.name}`);a.pr.add(n)}return t}if(r=l.get(d[0])){if(r.pr.has(n))throw new Error(`Mixed pr/sr ${n.name}`);return r.sr.add(n),n.rx.add(r),t}if(T){T.add(n),n.next=d[0];return}t=d[0],[...n.rx].sort((c,x)=>c.depth-x.depth).forEach(c=>{c.state===u?c.state=b:c.state===y&&p(c)})}}[s];n.rx=new Set,e[o]=n}),e),v=e=>{let o=T;T=new Set;let t,r;try{r=e()}catch(n){t=n}let s=T;if(T=o,t)throw t;return s.forEach(n=>{n(n.next),delete n.next}),r},h=(e,o)=>{let t=a;a=e;let r,s;try{s=o()}catch(n){r=n}if(a=t,r)throw r;return s};export{h as adopt,A as rx,k as rxPause,S as rxRegistry,i as rxUnsubscribe,v as transaction,V as vocals};
//# sourceMappingURL=index.js.map
